{"meta":{"title":"Mr.Liu","subtitle":"Write the Code. Change the world.","description":"Write the Code. Change the world.","author":"Mr.Liu","url":"http://ltx.host"},"pages":[{"title":"tags","date":"2017-02-09T10:56:16.000Z","updated":"2017-02-10T06:08:36.000Z","comments":false,"path":"tags/index.html","permalink":"http://ltx.host/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-02-09T10:56:25.000Z","updated":"2017-02-10T06:08:39.000Z","comments":false,"path":"categories/index.html","permalink":"http://ltx.host/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Swift基础知识(二) 函数、类等","slug":"BasicsOfSwift02","date":"2017-02-15T08:20:43.000Z","updated":"2017-02-15T08:11:12.000Z","comments":true,"path":"20170215/BasicsOfSwift02/","link":"","permalink":"http://ltx.host/20170215/BasicsOfSwift02/","excerpt":"这篇文章是自己学习Swift的笔记,本文主要介绍Swift中函数的使用、枚举类型、结构体、类的定义、类的构造函数、类的析构函数。","text":"这篇文章是自己学习Swift的笔记,本文主要介绍Swift中函数的使用、枚举类型、结构体、类的定义、类的构造函数、类的析构函数。 函数的使用函数的介绍1. 函数相当于OC中的方法2. 函数的格式如下1234func 函数名(参数列表) -&gt; 返回值类型 &#123; 代码块 return 返回值&#125; 3. func是关键字,多个参数列表之间可以用逗号（,）分隔，也可以没有参数4. 使用箭头“-&gt;”指向返回值类型5. 如果函数没有返回值，返回值为Void.并且“-&gt; 返回值类型”部分可以省略 常见的函数类型123456789101112131415161718192021222324252627282930313233// 1.没有参数,没有返回值的函数func about() -&gt; Void &#123; print(&quot;iPhone7&quot;)&#125;about()func about1() &#123; print(&quot;iPhone7&quot;)&#125;about1()// 2.有参数, 没有返回值的函数func callPhone(phoneNum : String) &#123; print(&quot;打电话给\\(phoneNum)&quot;)&#125;callPhone(phoneNum: &quot;+86 110&quot;)// 3.没有参数, 有返回值的函数func readMsg() -&gt; String &#123; return &quot;吃饭了吗?&quot;&#125;let msg = readMsg()// 4.有参数有返回值的函数func addTwoNum(num1 : Int, num2 : Int) -&gt; Int &#123; return num1 + num2&#125;let result = addTwoNum(num1: 20, num2: 30) 函数的使用注意注意一: 外部参数和内部参数 1. 在函数内部可以看到的参数,就是内部参数 2. 在函数外面可以看到的参数,就是外部参数 3. 默认所有的参数都是外部参数和内部参数 4. 如果不想要外部参数,可以在参数名称前加_123456789101112131415161718192021222324252627// 1.内部参数&amp;外部参数/*func sum(num1 : Int, num2 : Int) -&gt; Int &#123; return num1 + num2&#125;sum(num1: 20, num2: 30)*//*func sum(_ num1 : Int,_ num2 : Int) -&gt; Int &#123; return num1 + num2&#125;sum(20, 30)*/func sum(abc num1 : Int, cba num2 : Int) -&gt; Int &#123; return num1 + num2&#125;sum(abc: 20, cba: 30)// sum(20, 30) 注意二: 可变参数 1. swift中函数的参数个数可以变化，它可以接受不确定数量的输入类型参数 2. 它们必须具有相同的类型 3. 我们可以通过在参数类型名后面加入（…）的方式来指示这是可变参数123456789101112131415161718192021222324252627// 2.可变参数func sum(nums : Int...) -&gt; Int &#123; var total = 0 for num in nums &#123; total += num &#125; return total&#125;sum(nums: 20, 30, 40, 50)func myPrint(_ items : Any...) &#123; var strM : String = &quot;\\(items[0])&quot; for i in 1..&lt;items.count &#123; strM = strM + &quot; &quot; + &quot;\\(items[i])&quot; &#125; print(strM)&#125;print(20, 30, 40)myPrint(20, 30, 40) •注意三: 默认参数 1. 某些情况,如果没有传入具体的参数,可以使用默认参数 1234567func makeCoffee(coffeeName : String = &quot;雀巢&quot;) &#123; print(&quot;制作了一杯爱心\\(coffeeName)咖啡&quot;)&#125;makeCoffee(coffeeName: &quot;拿铁&quot;)makeCoffee(coffeeName: &quot;摩卡&quot;)makeCoffee() 注意四: 引用类型(指针的传递) 1. 默认情况下,函数的参数是值传递.如果想改变外面的变量,则需要传递变量的地址 2. 必须是变量,因为需要在内部改变其值 3. Swift提供的inout关键字就可以实现 4. 对比下列两个函数12345678910111213// 4.指针参数var m = 20var n = 30func swapNum(num1 : inout Int, num2 : inout Int) &#123; let temp = num1 num1 = num2 num2 = temp&#125;swap(&amp;m, &amp;n)print(&quot;m:\\(m) n:\\(n)&quot;) 枚举类型枚举类型的介绍1. 概念介绍 ◦ 枚举定义了一个通用类型的一组相关的值，使你可以在你的代码中以一个安全的方式来使用这些值。◦ 在 C/OC 语言中枚举指定相关名称为一组整型值◦ Swift 中的枚举更加灵活，不必给每一个枚举成员提供一个值.也可以提供一个值是字符串，一个字符，或是一个整型值或浮点值 2. 枚举类型的语法 ◦ 使用enum关键词并且把它们的整个定义放在一对大括号内 123enum SomeEnumeration &#123;// enumeration definition goes here&#125; 枚举类型的定义以下是指南针四个方向的一个例子 ◦ case关键词表明新的一行成员值将被定义 ◦ 不像 C 和 Objective-C 一样，Swift 的枚举成员在被创建时不会被赋予一个默认的整数值 ◦ 在上面的CompassPoints例子中，North，South，East和West不是隐式的等于0，1，2和3123456enum CompassPoint &#123; case North case South case East case West&#125; 定义方式二:多个成员值可以出现在同一行上123enum Planet &#123; case Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune&#125; 给枚举类型赋值枚举类型赋值可以是字符串/字符/整型/浮点型 注意： 如果有给枚举类型赋值,则必须在枚举类型后面明确说明具体的类型123456789101112131415161718192021222324252627282930313233343536// 1.枚举类型的赋值enum CompassPoint : Int &#123; case North = 1 case South = 2 case East = 3 case West = 4&#125;enum Planet &#123; case Mercury = 1, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune&#125;// 2.枚举类型的使用let p = Planet(rawValue: 3)if let p = p &#123; switch p &#123; case .Mercury: print(&quot;Mercury&quot;) case .Venus: print(&quot;Venus&quot;) case .Earth: print(&quot;Mercury&quot;) case .Mars: print(&quot;Mars&quot;) case .Jupiter: print(&quot;Jupiter&quot;) case .Saturn: print(&quot;Saturn&quot;) case .Uranus: print(&quot;Uranus&quot;) case .Neptune: print(&quot;Neptune&quot;) &#125;&#125; 结构体结构体的介绍1. 概念介绍 ◦ 结构体(struct)是由一系列具有相同类型或不同类型的数据构成的数据集合 ◦ 结构体(struct)指的是一种数据结构 ◦ 结构体是值类型,在方法中传递时是值传递2. 结构的定义格式123struct 结构体名称 &#123; // 属性和方法&#125; 结构体的使用1. 定义&amp;使用结构体12345678// 初始化结构体struct Location &#123; var x : Double var y : Double&#125;// 创建结构体let location = Location(x: 90, y: 90) 结构体的增强1. 扩充构造函数 ◦ 默认情况下创建Location时使用Location(x: x值, y: y值) ◦ 但是为了让我们在使用结构体时更加的灵活,swift还可以对构造函数进行扩充 ◦ 扩充的注意点: ▪ 在扩充的构造函数中必须保证成员变量是有值的 ▪ 扩充的构造函数会覆盖原有的构造函数123456789101112131415161718struct Location &#123; var x : Double var y : Double init(x : Double, y : Double) &#123; self.x = x self.y = y &#125; init(xyString : String) &#123; let strs = xyString.componentsSeparatedByString(&quot;,&quot;) x = Double(strs.first!)! y = Double(strs.last!)! &#125;&#125;let location = Location(x: 100, y: 100)let location1 = Location(xyString: &quot;100,100&quot;) 2. 为结构体扩充方法 ◦ 为了让结构体使用更加灵活,swift的结构体中可以扩充方法 ◦ 例子:为了Location结构体扩充两个方法 ①. 向水平方向移动的方法 ②. 向垂直方向移动的方法1234567891011121314151617181920212223struct Location &#123; var x : Double var y : Double init(x : Double, y : Double) &#123; self.x = x self.y = y &#125; init(xyString : String) &#123; let strs = xyString.componentsSeparatedByString(&quot;,&quot;) x = Double(strs.first!)! y = Double(strs.last!)! &#125; mutating func moveH(x : Double) &#123; self.x += x &#125; mutating func moveV(y : Double) &#123; self.y += y &#125;&#125; 注意: ◦ 如果我们使用的Location不是自己定义的，但是我们仍旧希望在自己的项目里扩展Location的操作 ◦ Swift也能帮我们达成，这个机制，叫做extension123456789extension Location &#123; mutating func moveH(x : Double) &#123; self.x += x &#125; mutating func moveV(y : Double) &#123; self.y += y &#125;&#125; Swift中类的使用一. 类的介绍和定义• Swift也是一门面向对象开发的语言• 面向对象的基础是类,类产生了对象• 在Swift中如何定义类呢? ◦ class是Swift中的关键字,用于定义类123class 类名 : SuperClass &#123; // 定义属性和方法&#125; 注意: ◦ 定义的类,可以没有父类.那么该类是rootClass ◦ 通常情况下,定义类时.继承自NSObject(非OC的NSObject) 二. 如何定义类的属性类的属性介绍 • Swift中类的属性有多种 ◦ 存储属性:存储实例的常量和变量 ◦ 计算属性:通过某种方式计算出来的属性 ◦ 类属性:与整个类自身相关的属性 存储属性• 存储属性是最简单的属性，它作为类实例的一部分，用于存储常量和变量• 可以给存储属性提供一个默认值，也可以在初始化方法中对其进行初始化• 下面是存储属性的写法 age和name都是存储属性,用来记录该学生的年龄和姓名chineseScore和mathScore也是存储属性,用来记录该学生的语文分数和数学分数 12345678910111213141516171819class Student : NSObject &#123; // 定义属性 // 存储属性 var age : Int = 0 var name : String? var chineseScore : Double = 0.0 var mathScore : Double = 0.0&#125;// 创建学生对象let stu = Student()// 给存储属性赋值stu.age = 10stu.name = &quot;why&quot;stu.chineseScore = 89.0stu.mathScore = 98.0 计算属性• 计算属性并不存储实际的值，而是提供一个getter和一个可选的setter来间接获取和设置其它属性• 计算属性一般只提供getter方法• 如果只提供getter，而不提供setter，则该计算属性为只读属性,并且可以省略get{}• 下面是计算属性的写法 averageScore是计算属性,通过chineseScore和mathScore计算而来的属性在setter方法中有一个newValue变量,是系统指定分配的 12345678910111213141516171819202122232425class Student : NSObject &#123; // 定义属性 // 存储属性 var age : Int = 0 var name : String? var chineseScore : Double = 0.0 var mathScore : Double = 0.0 // 计算属性 var averageScore : Double &#123; get &#123; return (chineseScore + mathScore) / 2 &#125; // 没有意义,因为之后获取值时依然是计算得到的 // newValue是系统分配的变量名,内部存储着新值 set &#123; self.averageScore = newValue &#125; &#125;&#125;// 获取计算属性的值print(stu.averageScore) 类属性• 类属性是与类相关联的，而不是与类的实例相关联• 所有的类和实例都共有一份类属性.因此在某一处修改之后,该类属性就会被修改• 类属性的设置和修改,需要通过类来完成• 下面是类属性的写法 ◦类属性使用static来修饰◦courseCount是类属性,用来记录学生有多少门课程 1234567891011121314151617181920212223242526272829class Student : NSObject &#123; // 定义属性 // 存储属性 var age : Int = 0 var name : String? var chineseScore : Double = 0.0 var mathScore : Double = 0.0 // 计算属性 var averageScore : Double &#123; get &#123; return (chineseScore + mathScore) / 2 &#125; // 没有意义.newValue是系统分配的变量名,内部存储着新值 set &#123; self.averageScore = newValue &#125; &#125; // 类属性 static var corseCount : Int = 0&#125;// 设置类属性的值Student.corseCount = 3// 取出类属性的值print(Student.corseCount) 监听属性的改变• 在OC中我们可以重写set方法来监听属性的改变• Swift中可以通过属性观察者来监听和响应属性值的变化• 通常是监听存储属性和类属性的改变.(对于计算属性，我们不需要定义属性观察者，因为我们可以在计算属性的setter中直接观察并响应这种值的变化) • 我们通过设置以下观察方法来定义观察者 ◦ willSet：在属性值被存储之前设置。此时新属性值作为一个常量参数被传入。该参数名默认为newValue，我们可以自己定义该参数名◦ didSet：在新属性值被存储后立即调用。与willSet相同，此时传入的是属性的旧值，默认参数名为oldValue◦ willSet与didSet只有在属性第一次被设置时才会调用，在初始化时，不会去调用这些监听方法 • 监听的方式如下: ◦ 监听age和name的变化 123456789101112131415161718192021222324252627class Person : NSObject &#123; var name : String? &#123; // 可以给newValue自定义名称 willSet (new)&#123; // 属性即将改变,还未改变时会调用的方法 // 在该方法中有一个默认的系统属性newValue,用于存储新值 print(name) print(new) &#125; // 可以给oldValue自定义名称 didSet (old) &#123; // 属性值已经改变了,会调用的方法 // 在该方法中有一个默认的系统属性oldValue,用于存储旧值 print(name) print(old) &#125; &#125; var age : Int = 0 var height : Double = 0.0&#125;let p : Person = Person()// 在赋值时,监听该属性的改变// 在OC中是通过重写set方法// 在swift中,可以给属性添加监听器p.name = &quot;why&quot;//p.name = &quot;yz&quot; 类的构造函数构造函数的介绍1. 构造函数类似于OC中的初始化方法:init方法2. 默认情况下载创建一个类时,必然会调用一个构造函数3. 即便是没有编写任何构造函数，编译器也会提供一个默认的构造函数。4. 如果是继承自NSObject,可以对父类的构造函数进行重写 构造函数的基本使用1. 类的属性必须有值2. 如果不是在定义时初始化值,可以在构造函数中赋值12345678910111213class Person: NSObject &#123; var name : String var age : Int // 重写了NSObject(父类)的构造方法 override init() &#123; name = &quot;&quot; age = 0 &#125;&#125;// 创建一个Person对象let p = Person() 初始化时给属性赋值• 很多时候,我们在创建一个对象时就会给属性赋值• 可以自定义构造函数注意:如果自定义了构造函数,会覆盖init()方法.即不在有默认的构造函数12345678910111213class Person: NSObject &#123; var name : String var age : Int // 自定义构造函数,会覆盖init()函数 init(name : String, age : Int) &#123; self.name = name self.age = age &#125;&#125;// 创建一个Person对象let p = Person(name: &quot;why&quot;, age: 18) 字典转模型(初始化时传入字典)• 真实创建对象时,更多的是将字典转成模型• 注意: ◦ 去字典中取出的是NSObject,任意类型.◦ 可以通过as!转成需要的类型,再赋值(不可以直接赋值) 1234567891011121314class Person: NSObject &#123; var name : String var age : Int // 自定义构造函数,会覆盖init()函数 init(dict : [String : NSObject]) &#123; name = dict[&quot;name&quot;] as! String age = dict[&quot;age&quot;] as! Int &#125;&#125;// 创建一个Person对象let dict = [&quot;name&quot; : &quot;why&quot;, &quot;age&quot; : 18]let p = Person(dict: dict) 字典转模型(利用KVC转化)• 利用KVC字典转模型会更加方便•注意:◦ KVC并不能保证会给所有的属性赋值◦ 因此属性需要有默认值 ▪ 基本数据类型默认值设置为0▪ 对象或者结构体类型定义为可选类型即可(可选类型没有赋值前为nil) 1234567891011121314151617181920class Person: NSObject &#123; // 结构体或者类的类型,必须是可选类型.因为不能保证一定会赋值 var name : String? // 基本数据类型不能是可选类型,否则KVC无法转化 var age : Int = 0 // 自定义构造函数,会覆盖init()函数 init(dict : [String : NSObject]) &#123; // 必须先初始化对象 super.init() // 调用对象的KVC方法字典转模型 setValuesForKeysWithDictionary(dict) &#125;&#125;// 创建一个Person对象let dict = [&quot;name&quot; : &quot;why&quot;, &quot;age&quot; : 18]let p = Person(dict: dict) 类的析构函数##析构函数1. Swift 会自动释放不再需要的实例以释放资源◦ Swift 通过自动引用计数（ARC）处理实例的内存管理◦ 当引用计数为0时,系统会自动调用析构函数(不可以手动调用)◦ 通常在析构函数中释放一些资源(如移除通知等操作)2. 析构函数的写法123deinit &#123; // 执行析构过程&#125; 示例练习12345678910111213141516class Person &#123; var name : String var age : Int init(name : String, age : Int) &#123; self.name = name self.age = age &#125; deinit &#123; print(&quot;Person-deinit&quot;) &#125;&#125;var p : Person? = Person(name: &quot;why&quot;, age: 18)p = nil","categories":[{"name":"Swift","slug":"Swift","permalink":"http://ltx.host/categories/Swift/"}],"tags":[{"name":"Swift基础","slug":"Swift基础","permalink":"http://ltx.host/tags/Swift基础/"},{"name":"基本数据类型","slug":"基本数据类型","permalink":"http://ltx.host/tags/基本数据类型/"}]},{"title":"Swift基础知识（一）基本数据类型","slug":"BasicsOfSwift01","date":"2017-02-15T01:50:43.000Z","updated":"2017-02-15T03:38:19.000Z","comments":true,"path":"20170215/BasicsOfSwift01/","link":"","permalink":"http://ltx.host/20170215/BasicsOfSwift01/","excerpt":"这篇文章是自己学习Swift的笔记,属于入门教程，介绍Swift基本语法知识，比较枯燥，建议大家使用Playground亲自动手敲一遍，以加深记忆。","text":"这篇文章是自己学习Swift的笔记,属于入门教程，介绍Swift基本语法知识，比较枯燥，建议大家使用Playground亲自动手敲一遍，以加深记忆。 字符串的使用字符串的介绍1. 字符串在任何的开发中使用都是非常频繁的2. OC和Swift中字符串的区别: 在OC中字符串类型时NSString,在Swift中字符串类型是StringOC中字符串@””,Swift中字符串”” 3. 使用 String 的原因: String 是一个结构体，性能更高NSString 是一个 OC 对象，性能略差String 支持直接遍历Swift 提供了 String 和 NSString 之间的无缝转换 字符的定义* 定义不可变字符串 123// 1&gt; 定义不可变字符串 : 使用let修饰let str : String = &quot;hello swift&quot;// str = &quot;hello Objective-C&quot; 错误写法 * 定义可变字符串 123// 2&gt; 定义可变字符串 : 使用var修饰var strM : String = &quot;hello world&quot;strM = &quot;hello china&quot; 字符串的使用获取字符串的长度获取字符集合,再获取集合的count属性 1let count = str.characters.count 字符串拼接 1.两个字符串的拼接123let str1 = &quot;Hello&quot;let str2 = &quot;World&quot;let str3 = str1 + str2 2.字符串和其他数据类型的拼接1234let name = &quot;why&quot;let age = 18let info = &quot;my name is \\(name), age is \\(age)&quot; 3.字符串的格式化 比如时间:03:041234let min = 3let second = 4let time = String(format: &quot;%02d:%02d&quot;, arguments: [min, second]) 字符串的截取1.Swift中提供了特殊的截取方式： 该方式非常麻烦Index创建较为麻烦 2.简单的方式是将String转成NSString来使用 在标识符后加:as NSString即可 1234567let urlString = &quot;www.liutianxiang.com&quot;// Swift中通过 as 关键字可以将String类型转成NSString的类型let header1 = (urlString as NSString).substring(to: 3)let footer1 = (urlString as NSString).substring(from: 10)let range1 = NSRange(location: 4, length: 5)let middle1 = (urlString as NSString).substring(with: range1) swift截取方式123456789101112let urlString = &quot;www.liutianxiang.com&quot;let headerIndex = urlString.index(urlString.startIndex, offsetBy: 3)let header2 = urlString.substring(to: headerIndex)let footerIndex = urlString.index(urlString.endIndex, offsetBy: -3)let footer2 = urlString.substring(from: footerIndex)let startIndex = urlString.index(urlString.startIndex, offsetBy: 4)let endIndex = urlString.index(urlString.startIndex, offsetBy: 9)let range2 = Range(startIndex..&lt;endIndex)let middle2 = urlString.substring(with: range2) 数组的使用数组的介绍1.数组（Array）是一串有序的由相同类型元素构成的集合2.数组中的集合元素是有序的，可以重复出现3.swift中的数组类型是Array，是一个泛型集合 数组的初始化*数组分成:可变数组和不可变数组 ◦ 使用let修饰的数组是不可变数组 ◦ 使用var修饰的数组是可变数组 定义不可变数组1let array : [Any] = [&quot;why&quot;, 18, 1.88] 定义可变数组1var arrayM = [Any]() 对数组的基本操作1234567891011// 添加数据array.append(&quot;yz&quot;)// 删除元素array.removeFirst()// 修改元素array[0] = &quot;why&quot;// 取值array[1] 数组的遍历123456789101112131415161718192021// 遍历数组for i in 0..&lt;array.count &#123; print(array[i])&#125;// forin方式for item in array &#123; print(item)&#125;// 设置遍历的区间for item in array[0..&lt;2] &#123; print(item)&#125;// 遍历数组的同时获取下标值let names = [&quot;why&quot;, &quot;yz&quot;, &quot;lnj&quot;, &quot;lmj&quot;]for (index, name) in names.enumerate() &#123; print(index) print(name)&#125; 数组的合并12345678910// 数组合并// 注意:只有相同类型的数组才能合并var array = [&quot;why&quot;, &quot;lmj&quot;,&quot;lnj&quot;]var array1 = [&quot;yz&quot;, &quot;wsz&quot;]var array2 = array + array1;// 不建议一个数组中存放多种类型的数据var array3 = [2, 3, &quot;why&quot;]var array4 = [&quot;yz&quot;, 23]array3 + array4 字典的使用字典的介绍• 字典允许按照某个键来访问元素• 字典是由两部分集合构成的，一个是键（key）集合，一个是值（value）集合• 键集合是不能有重复元素的，而值集合是可以重复的，键和值是成对出现的• Swift中的字典类型是Dictionary，也是一个泛型集合 字典的初始化• Swift中的可变和不可变字典 ◦ 使用let修饰的数组是不可变字典 ◦ 使用var修饰的数组是可变字典 12345// 定义一个可变字典var dict1 : [String : Any] = [String : Any]()// 定义一个不可变字典let dict2 : [String : Any] = [&quot;name&quot; : &quot;why&quot;, &quot;age&quot; : 18] 字典的基本操作12345678910111213141516// 添加数据dict[&quot;height&quot;] = 1.88dict[&quot;weight&quot;] = 70.0dict// 删除字段dict.removeValueForKey(&quot;height&quot;)dict// 修改字典dict[&quot;name&quot;] = &quot;lmj&quot;dict.updateValue(&quot;lmj&quot;, forKey: &quot;name&quot;)dict// 查询字典dict[&quot;name&quot;] 字典的遍历1234567891011121314// 遍历字典中所有的值for value in dict.values &#123; print(value)&#125;// 遍历字典中所有的键for key in dict.keys &#123; print(key)&#125;// 遍历所有的键值对for (key, value) in dict &#123; print(key) print(value)&#125; 字典的合并1234567// 字典的合并var dict1 = [&quot;name&quot; : &quot;yz&quot;, &quot;age&quot; : 20]var dict2 = [&quot;height&quot; : 1.87, &quot;phoneNum&quot; : &quot;+86 110&quot;]// 字典不可以相加合并for (key, value) in dict1 &#123; dict2[key] = value&#125; 元组的使用元组的介绍• 元组是Swift中特有的,OC中并没有相关类型• 它是什么呢? 它是一种数据结构，在数学中应用广泛 类似于数组或者字典 可以用于定义一组数据 组成元组类型的数据可以称为“元素” 元组的定义• 元组的常见写法1234// 使用元组描述一个人的信息(&quot;1001&quot;, &quot;张三&quot;, 30, 90)// 给元素加上元素名称,之后可以通过元素名称访问元素(id:&quot;1001&quot;, name:&quot;张三&quot;, english_score:30, chinese_score:90) 元组的简单使用• 用元组来描述一个HTTP的错误信息12345678910111213141516// 元组:HTTP错误// let array = [404, &quot;Not Found&quot;]// 写法一:let error = (404, &quot;Not Found&quot;)print(error.0)print(error.1)// 写法二:let error = (errorCode : 404, errorInfo : &quot;Not Found&quot;)print(error.errorCode)print(error.errorInfo)// 写法三:let (errorCode, errorIno) = (404, &quot;Not Found&quot;)print(errorCode)print(errorIno) 可选类型可选类型的介绍注意 ◦ 可选类型时swift中较理解的一个知识点 ◦ 暂时先了解,多利用Xcode的提示来使用 ◦ 随着学习的深入,慢慢理解其中的原理和好处概念: ◦ 在OC开发中,如果一个变量暂停不使用,可以赋值为0(基本属性类型)或者赋值为空(对象类型) ◦ 在swift开发中,nil也是一个特殊的类型.因为和真实的类型不匹配是不能赋值的(swift是强类型语言) ◦ 但是开发中赋值nil,在所难免.因此推出了可选类型可选类型的取值: ◦ 空值 ◦ 有值 定义可选类型定义一个可选类型有两种写法 ◦ 最基本的写法 ◦ 语法糖(常用)123456789// 错误写法// let string : String = nil// 正确写法:// 注意:name的类型是一个可选类型,但是该可选类型中可以存放字符串.// 写法一:定义可选类型let name : Optional&lt;String&gt; = nil// 写法二:定义可选类型,语法糖(常用)let name : String? = nil 可选类型的使用1234567891011121314151617181920212223242526272829303132333435// 演练一:给可选类型赋值// 定义可选类型var string : Optional&lt;String&gt; = nil// 给可选类型赋值// 错误写法:因此该可选类型中只能存放字符串string = 123// 正确写法:string = &quot;Hello world&quot;// 打印结果print(string)// 结果:Optional(&quot;Hello world&quot;)\\n// 因为打印出来的是可选类型,所有会带Optional// 演练二:取出可选类型的值// 取出可选类型的真实值(解包)print(string!)// 结果:Hello world\\n// 注意:如果可选类型为nil,强制取出其中的值(解包),会出错string = nilprint(string!) // 报错// 正确写法:if string != nil &#123; print(string!)&#125;// 简单写法:为了让在if语句中可以方便使用string// 可选绑定if let str = string &#123; print(str)&#125; 真实应用场景目的: 让代码更加严谨1234567891011121314151617// 1.将字符串类型转成Int类型let str = &quot;123&quot;let result : Int? = Int(str) // nil/Int// 2.根据文件名称,读取路径let path : String? = Bundle.main.path(forResource: &quot;123.plist&quot;, ofType: nil)// 3.根据string,创建URLlet url = URL(string: &quot;http://www.520it.com/小码哥&quot;)// 4.从字典中取内容let dict : [String : Any] = [&quot;name&quot; : &quot;why&quot;, &quot;age&quot; : 18]dict[&quot;name&quot;]dict[&quot;height&quot;]","categories":[{"name":"Swift","slug":"Swift","permalink":"http://ltx.host/categories/Swift/"}],"tags":[{"name":"Swift基础","slug":"Swift基础","permalink":"http://ltx.host/tags/Swift基础/"},{"name":"基本数据类型","slug":"基本数据类型","permalink":"http://ltx.host/tags/基本数据类型/"}]},{"title":"NavigationBar自动隐藏和显示","slug":"NavigationBarHidden","date":"2017-02-13T01:23:30.000Z","updated":"2017-02-13T08:31:48.000Z","comments":true,"path":"20170213/NavigationBarHidden/","link":"","permalink":"http://ltx.host/20170213/NavigationBarHidden/","excerpt":"LTX.Host UIScrollView中可以实现以下方法使得NavigationBar根据手势滑动方向自动隐藏或者显示。","text":"LTX.Host UIScrollView中可以实现以下方法使得NavigationBar根据手势滑动方向自动隐藏或者显示。 123456789101112- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset&#123; if(velocity.y &gt; 0) &#123; //上滑 隐藏 [self.navigationController setNavigationBarHidden:YES animated:YES]; &#125;else &#123; //下滑 显示 [self.navigationController setNavigationBarHidden:NO animated:YES]; &#125; &#125;","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://ltx.host/categories/Objective-C/"}],"tags":[{"name":"UIScrollView","slug":"UIScrollView","permalink":"http://ltx.host/tags/UIScrollView/"},{"name":"UINavigationBar","slug":"UINavigationBar","permalink":"http://ltx.host/tags/UINavigationBar/"}]},{"title":"iOS中float、double类型直接计算导致精度不准确问题","slug":"NSDecimalNumber","date":"2017-02-10T01:50:51.000Z","updated":"2017-02-10T02:26:32.000Z","comments":true,"path":"20170210/NSDecimalNumber/","link":"","permalink":"http://ltx.host/20170210/NSDecimalNumber/","excerpt":"做金融类App开发，经常涉及到Money的计算问题，特别是在算利息这种情况时会遇到除不尽导致小数位数过多的问题。","text":"做金融类App开发，经常涉及到Money的计算问题，特别是在算利息这种情况时会遇到除不尽导致小数位数过多的问题。 问题引出1234567891011121314 //申请提现金额 double balance = [_withDrawView.balanceField.text doubleValue]; //手续费 double brokerage = 1.00; //预计到账金额 (申请提现金额 - 手续费) double finalBalance = balance -brokerage; //提交需要转成NSNumber NSNumber *b = [NSNumber numberWithDouble:balance]; NSNumber *fb = [NSNumber numberWithDouble:finalBalance]; DLog(@&quot;申请金额:%@ 预计到账金额:%@&quot;,b, fb);// 输入金额为10.21后输出结果 申请金额:10.21 预计到账金额:9.210000000000001 可以看到，经过计算的金额转成NSNumber类型后精度不准确，这不是我们想要的结果！ 解决方案1234567891011// //申请提现金额// NSDecimalNumber *balance = [NSDecimalNumber decimalNumberWithString:[NSString stringWithFormat:@&quot;%@&quot;, _withDrawView.balanceField.text]];// //手续费// NSDecimalNumber* brokerage = [NSDecimalNumber decimalNumberWithString:[NSString stringWithFormat:@&quot;%f&quot;,1.00]];// //预计到账金额 (申请提现金额 - 手续费)// NSDecimalNumber* finalBalance = [balance decimalNumberBySubtracting:brokerage];////// DLog(@&quot;申请金额:%@ 预计到账金额:%@&quot;,balance, finalBalance);// 输入金额为10.21后输出结果 申请金额:10.21 预计到账金额:9.21 这就对了，开发中我们可以把float、double转成NSDecimalNumber类型后再进行+、-、* 、/ 的运算。","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://ltx.host/categories/Objective-C/"}],"tags":[{"name":"double计算","slug":"double计算","permalink":"http://ltx.host/tags/double计算/"},{"name":"精度丢失","slug":"精度丢失","permalink":"http://ltx.host/tags/精度丢失/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-02-09T10:39:27.000Z","updated":"2017-02-09T10:39:27.000Z","comments":true,"path":"20170209/hello-world/","link":"","permalink":"http://ltx.host/20170209/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Could not get BatchedBridge","slug":"BatchedBridge","date":"2017-02-08T12:05:41.000Z","updated":"2017-02-09T15:18:11.000Z","comments":true,"path":"20170208/BatchedBridge/","link":"","permalink":"http://ltx.host/20170208/BatchedBridge/","excerpt":"","text":"Could not get BatchedBridge, make sure your bundle is packaged correctly首先在项目的目录android/app/src/main/下面 查看有没有assets文件夹，如果没有手动创建一个。然后打开终端 cd到项目根目录执行下面命令1react-native bundle --platform android --dev false --entry-file index.android.js --bundle-output android/app/src/main/assets/index.android.bundle --assets-dest android/app/src/main/res/","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://ltx.host/categories/React-Native/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"http://ltx.host/tags/React-Native/"},{"name":"移动端","slug":"移动端","permalink":"http://ltx.host/tags/移动端/"}]},{"title":"iOS Runtime 获取成员变量","slug":"RuntimeGet","date":"2017-02-08T12:05:41.000Z","updated":"2017-02-09T15:30:35.000Z","comments":true,"path":"20170208/RuntimeGet/","link":"","permalink":"http://ltx.host/20170208/RuntimeGet/","excerpt":"","text":"首先包含runtime头文件1#import &lt;objc/runtime.h&gt; 以UITextField为例 1.遍历所有成员变量12345678910111213141516171819+ (void)initialize&#123; unsigned int count = 0; // 拷贝出所有的成员变量列表 Ivar *ivars = class_copyIvarList([UITextField class], &amp;count); for (int i = 0; i&lt;count; i++) &#123; // 取出成员变量 // Ivar ivar = *(ivars + i); Ivar ivar = ivars[i]; // 打印成员变量名字 XMGLog(@&quot;%s %s&quot;, ivar_getName(ivar), ivar_getTypeEncoding(ivar)); &#125; // 释放 free(ivars);&#125; 2.遍历所有属性12345678910111213141516+ (void)initialize&#123; unsigned int count = 0; objc_property_t *properties = class_copyPropertyList([UITextField class], &amp;count); for (int i = 0; i&lt;count; i++) &#123; // 取出属性 objc_property_t property = properties[i]; // 打印属性名字 XMGLog(@&quot;%s &lt;----&gt; %s&quot;, property_getName(property), property_getAttributes(property)); &#125; free(properties);&#125;","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://ltx.host/categories/Objective-C/"}],"tags":[{"name":"Runtime","slug":"Runtime","permalink":"http://ltx.host/tags/Runtime/"},{"name":"iOS","slug":"iOS","permalink":"http://ltx.host/tags/iOS/"}]},{"title":"Swift基本语法之闭包","slug":"SwiftClosures","date":"2017-02-08T12:05:41.000Z","updated":"2017-02-09T16:15:58.000Z","comments":true,"path":"20170208/SwiftClosures/","link":"","permalink":"http://ltx.host/20170208/SwiftClosures/","excerpt":"","text":"主要内容闭包的介绍闭包和OC中的block非常相似 OC中的block是匿名的函数Swift中的闭包是一个特殊的函数block和闭包都经常用于回调 注意:闭包和block一样,第一次使用时可能不习惯它的语法,可以先按照使用简单的闭包,随着学习的深入,慢慢掌握其灵活的运用方法. 闭包的使用block的用法回顾定义网络请求的类12345678910111213141516@interface HttpTool : NSObject- (void)loadRequest:(void (^)())callBackBlock;@end@implementation HttpTool- (void)loadRequest:(void (^)())callBackBlock&#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@&quot;加载网络数据:%@&quot;, [NSThread currentThread]); dispatch_async(dispatch_get_main_queue(), ^&#123; callBackBlock(); &#125;); &#125;);&#125;@end 进行网络请求,请求到数据后利用block进行回调123456- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; [self.httpTool loadRequest:^&#123; NSLog(@&quot;主线程中,将数据回调.%@&quot;, [NSThread currentThread]); &#125;];&#125; block写法总结:12345678block的写法: 类型: 返回值(^block的名称)(block的参数) 值: ^(参数列表) &#123; // 执行的代码 &#125;; 使用闭包代替block定义网络请求的类123456789101112class HttpTool: NSObject &#123; func loadRequest(callBack : ()-&gt;())&#123; dispatch_async(dispatch_get_global_queue(0, 0)) &#123; () -&gt; Void in print(&quot;加载数据&quot;, [NSThread.currentThread()]) dispatch_async(dispatch_get_main_queue(), &#123; () -&gt; Void in callBack() &#125;) &#125; &#125;&#125; 进行网络请求,请求到数据后利用闭包进行回调123456override func touchesBegan(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?) &#123; // 网络请求 httpTool.loadRequest (&#123; () -&gt; () in print(&quot;回到主线程&quot;, NSThread.currentThread()); &#125;)&#125; 闭包写法总结:123456789闭包的写法: 类型:(形参列表)-&gt;(返回值) 技巧:初学者定义闭包类型,直接写()-&gt;().再填充参数和返回值 值: &#123; (形参) -&gt; 返回值类型 in // 执行代码 &#125; 闭包的简写如果闭包没有参数,没有返回值.in和in之前的内容可以省略123httpTool.loadRequest(&#123; print(&quot;回到主线程&quot;, NSThread.currentThread()); &#125;) 尾随闭包写法: 如果闭包是函数的最后一个参数,则可以将闭包写在()后面 如果函数只有一个参数,并且这个参数是闭包,那么()可以不写 12345678httpTool.loadRequest() &#123; print(&quot;回到主线程&quot;, NSThread.currentThread());&#125;// 开发中建议该写法httpTool.loadRequest &#123; print(&quot;回到主线程&quot;, NSThread.currentThread());&#125; 闭包的循环引用 •如果在HttpTool中有对闭包进行强引用,则会形成循环引用 •补充:在Swift中检测一个对象是否销毁,可以实现对象的deinit函数 1234// 析构函数(相当于OC中dealloc方法) deinit &#123; print(&quot;ViewController----deinit&quot;) &#125; 循环引用的(实现) 该实现是为了产生循环引用,而产生的循环引用 123456789101112131415class HttpTool: NSObject &#123; // 定义属性,来强引用传入的闭包 var callBack : (()-&gt;())? func loadRequest(callBack : ()-&gt;())&#123; dispatch_async(dispatch_get_global_queue(0, 0)) &#123; () -&gt; Void in print(&quot;加载数据&quot;, [NSThread.currentThread()]) dispatch_async(dispatch_get_main_queue(), &#123; () -&gt; Void in callBack() &#125;) &#125; self.callBack = callBack &#125;&#125; swift中解决循环引用的方式方案一: 使用weak,对当前控制器使用弱引用但是因为self可能有值也可能没有值,因此weakSelf是一个可选类型,在真正使用时可以对其强制解包(该处强制解包没有问题,因为控制器一定存在,否则无法调用所在函数) 123456// 解决方案一: weak var weakSelf = self httpTool.loadData &#123; print(&quot;加载数据完成,更新界面:&quot;, NSThread.currentThread()) weakSelf!.view.backgroundColor = UIColor.redColor() &#125; 方案二: 和方案一类型,只是书写方式更加简单 可以写在闭包中,并且在闭包中用到的self都是弱引用 1234httpTool.loadData &#123;[weak self] () -&gt; () in print(&quot;加载数据完成,更新界面:&quot;, NSThread.currentThread()) self!.view.backgroundColor = UIColor.redColor() &#125; 方案三:(常用) ◦ 使用关键字`unowned` ◦ 从行为上来说 unowned 更像OC中的 unsafe_unretained ◦ unowned 表示:即使它原来引用的对象被释放了，仍然会保持对被已经释放了的对象的一个 &quot;无效的&quot; 引用，它不能是 Optional 值，也不会被指向 nil 1234httpTool.loadData &#123;[unowned self] () -&gt; () in print(&quot;加载数据完成,更新界面:&quot;, NSThread.currentThread()) self.view.backgroundColor = UIColor.redColor() &#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"http://ltx.host/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://ltx.host/tags/Swift/"},{"name":"闭包","slug":"闭包","permalink":"http://ltx.host/tags/闭包/"}]}]}