{"meta":{"title":"Mr.Liu","subtitle":"Write the Code. Change the world.","description":"Write the Code. Change the world.","author":"Mr.Liu","url":"http://ltx.host"},"pages":[{"title":"categories","date":"2017-02-09T10:56:25.000Z","updated":"2017-02-10T06:08:39.000Z","comments":false,"path":"categories/index.html","permalink":"http://ltx.host/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-02-09T10:56:16.000Z","updated":"2017-02-10T06:08:36.000Z","comments":false,"path":"tags/index.html","permalink":"http://ltx.host/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Swift基础知识（一）基本数据类型","slug":"BasicsOfSwift01","date":"2017-02-15T01:50:43.000Z","updated":"2017-02-15T03:30:57.000Z","comments":true,"path":"20170215/BasicsOfSwift01/","link":"","permalink":"http://ltx.host/20170215/BasicsOfSwift01/","excerpt":"Swift 这篇文章是自己学习Swift的笔记,属于入门教程，介绍Swift基本语法知识，比较枯燥，建议大家使用Playground亲自动手敲一遍，以加深记忆。","text":"Swift 这篇文章是自己学习Swift的笔记,属于入门教程，介绍Swift基本语法知识，比较枯燥，建议大家使用Playground亲自动手敲一遍，以加深记忆。 字符串的使用字符串的介绍1. 字符串在任何的开发中使用都是非常频繁的2. OC和Swift中字符串的区别: 在OC中字符串类型时NSString,在Swift中字符串类型是StringOC中字符串@””,Swift中字符串”” 3. 使用 String 的原因: String 是一个结构体，性能更高NSString 是一个 OC 对象，性能略差String 支持直接遍历Swift 提供了 String 和 NSString 之间的无缝转换 字符的定义* 定义不可变字符串 123// 1&gt; 定义不可变字符串 : 使用let修饰let str : String = &quot;hello swift&quot;// str = &quot;hello Objective-C&quot; 错误写法 * 定义可变字符串 123// 2&gt; 定义可变字符串 : 使用var修饰var strM : String = &quot;hello world&quot;strM = &quot;hello china&quot; 字符串的使用获取字符串的长度获取字符集合,再获取集合的count属性 1let count = str.characters.count 字符串拼接 1.两个字符串的拼接123let str1 = &quot;Hello&quot;let str2 = &quot;World&quot;let str3 = str1 + str2 2.字符串和其他数据类型的拼接1234let name = &quot;why&quot;let age = 18let info = &quot;my name is \\(name), age is \\(age)&quot; 3.字符串的格式化 比如时间:03:041234let min = 3let second = 4let time = String(format: &quot;%02d:%02d&quot;, arguments: [min, second]) 字符串的截取1.Swift中提供了特殊的截取方式： 该方式非常麻烦Index创建较为麻烦 2.简单的方式是将String转成NSString来使用 在标识符后加:as NSString即可 1234567let urlString = &quot;www.liutianxiang.com&quot;// Swift中通过 as 关键字可以将String类型转成NSString的类型let header1 = (urlString as NSString).substring(to: 3)let footer1 = (urlString as NSString).substring(from: 10)let range1 = NSRange(location: 4, length: 5)let middle1 = (urlString as NSString).substring(with: range1) swift截取方式123456789101112let urlString = &quot;www.liutianxiang.com&quot;let headerIndex = urlString.index(urlString.startIndex, offsetBy: 3)let header2 = urlString.substring(to: headerIndex)let footerIndex = urlString.index(urlString.endIndex, offsetBy: -3)let footer2 = urlString.substring(from: footerIndex)let startIndex = urlString.index(urlString.startIndex, offsetBy: 4)let endIndex = urlString.index(urlString.startIndex, offsetBy: 9)let range2 = Range(startIndex..&lt;endIndex)let middle2 = urlString.substring(with: range2) 数组的使用数组的介绍1.数组（Array）是一串有序的由相同类型元素构成的集合2.数组中的集合元素是有序的，可以重复出现3.swift中的数组类型是Array，是一个泛型集合 数组的初始化*数组分成:可变数组和不可变数组 ◦ 使用let修饰的数组是不可变数组 ◦ 使用var修饰的数组是可变数组 定义不可变数组1let array : [Any] = [&quot;why&quot;, 18, 1.88] 定义可变数组1var arrayM = [Any]() 对数组的基本操作1234567891011// 添加数据array.append(&quot;yz&quot;)// 删除元素array.removeFirst()// 修改元素array[0] = &quot;why&quot;// 取值array[1] 数组的遍历123456789101112131415161718192021// 遍历数组for i in 0..&lt;array.count &#123; print(array[i])&#125;// forin方式for item in array &#123; print(item)&#125;// 设置遍历的区间for item in array[0..&lt;2] &#123; print(item)&#125;// 遍历数组的同时获取下标值let names = [&quot;why&quot;, &quot;yz&quot;, &quot;lnj&quot;, &quot;lmj&quot;]for (index, name) in names.enumerate() &#123; print(index) print(name)&#125; 数组的合并12345678910// 数组合并// 注意:只有相同类型的数组才能合并var array = [&quot;why&quot;, &quot;lmj&quot;,&quot;lnj&quot;]var array1 = [&quot;yz&quot;, &quot;wsz&quot;]var array2 = array + array1;// 不建议一个数组中存放多种类型的数据var array3 = [2, 3, &quot;why&quot;]var array4 = [&quot;yz&quot;, 23]array3 + array4 字典的使用字典的介绍• 字典允许按照某个键来访问元素• 字典是由两部分集合构成的，一个是键（key）集合，一个是值（value）集合• 键集合是不能有重复元素的，而值集合是可以重复的，键和值是成对出现的• Swift中的字典类型是Dictionary，也是一个泛型集合 字典的初始化• Swift中的可变和不可变字典 ◦ 使用let修饰的数组是不可变字典 ◦ 使用var修饰的数组是可变字典 12345// 定义一个可变字典var dict1 : [String : Any] = [String : Any]()// 定义一个不可变字典let dict2 : [String : Any] = [&quot;name&quot; : &quot;why&quot;, &quot;age&quot; : 18] 字典的基本操作12345678910111213141516// 添加数据dict[&quot;height&quot;] = 1.88dict[&quot;weight&quot;] = 70.0dict// 删除字段dict.removeValueForKey(&quot;height&quot;)dict// 修改字典dict[&quot;name&quot;] = &quot;lmj&quot;dict.updateValue(&quot;lmj&quot;, forKey: &quot;name&quot;)dict// 查询字典dict[&quot;name&quot;] 字典的遍历1234567891011121314// 遍历字典中所有的值for value in dict.values &#123; print(value)&#125;// 遍历字典中所有的键for key in dict.keys &#123; print(key)&#125;// 遍历所有的键值对for (key, value) in dict &#123; print(key) print(value)&#125; 字典的合并1234567// 字典的合并var dict1 = [&quot;name&quot; : &quot;yz&quot;, &quot;age&quot; : 20]var dict2 = [&quot;height&quot; : 1.87, &quot;phoneNum&quot; : &quot;+86 110&quot;]// 字典不可以相加合并for (key, value) in dict1 &#123; dict2[key] = value&#125; 元组的使用元组的介绍• 元组是Swift中特有的,OC中并没有相关类型• 它是什么呢? 它是一种数据结构，在数学中应用广泛 类似于数组或者字典 可以用于定义一组数据 组成元组类型的数据可以称为“元素” 元组的定义• 元组的常见写法1234// 使用元组描述一个人的信息(&quot;1001&quot;, &quot;张三&quot;, 30, 90)// 给元素加上元素名称,之后可以通过元素名称访问元素(id:&quot;1001&quot;, name:&quot;张三&quot;, english_score:30, chinese_score:90) 元组的简单使用• 用元组来描述一个HTTP的错误信息12345678910111213141516// 元组:HTTP错误// let array = [404, &quot;Not Found&quot;]// 写法一:let error = (404, &quot;Not Found&quot;)print(error.0)print(error.1)// 写法二:let error = (errorCode : 404, errorInfo : &quot;Not Found&quot;)print(error.errorCode)print(error.errorInfo)// 写法三:let (errorCode, errorIno) = (404, &quot;Not Found&quot;)print(errorCode)print(errorIno) 可选类型可选类型的介绍注意 ◦ 可选类型时swift中较理解的一个知识点 ◦ 暂时先了解,多利用Xcode的提示来使用 ◦ 随着学习的深入,慢慢理解其中的原理和好处概念: ◦ 在OC开发中,如果一个变量暂停不使用,可以赋值为0(基本属性类型)或者赋值为空(对象类型) ◦ 在swift开发中,nil也是一个特殊的类型.因为和真实的类型不匹配是不能赋值的(swift是强类型语言) ◦ 但是开发中赋值nil,在所难免.因此推出了可选类型可选类型的取值: ◦ 空值 ◦ 有值 定义可选类型定义一个可选类型有两种写法 ◦ 最基本的写法 ◦ 语法糖(常用)123456789// 错误写法// let string : String = nil// 正确写法:// 注意:name的类型是一个可选类型,但是该可选类型中可以存放字符串.// 写法一:定义可选类型let name : Optional&lt;String&gt; = nil// 写法二:定义可选类型,语法糖(常用)let name : String? = nil 可选类型的使用1234567891011121314151617181920212223242526272829303132333435// 演练一:给可选类型赋值// 定义可选类型var string : Optional&lt;String&gt; = nil// 给可选类型赋值// 错误写法:因此该可选类型中只能存放字符串string = 123// 正确写法:string = &quot;Hello world&quot;// 打印结果print(string)// 结果:Optional(&quot;Hello world&quot;)\\n// 因为打印出来的是可选类型,所有会带Optional// 演练二:取出可选类型的值// 取出可选类型的真实值(解包)print(string!)// 结果:Hello world\\n// 注意:如果可选类型为nil,强制取出其中的值(解包),会出错string = nilprint(string!) // 报错// 正确写法:if string != nil &#123; print(string!)&#125;// 简单写法:为了让在if语句中可以方便使用string// 可选绑定if let str = string &#123; print(str)&#125; 真实应用场景目的: 让代码更加严谨1234567891011121314151617// 1.将字符串类型转成Int类型let str = &quot;123&quot;let result : Int? = Int(str) // nil/Int// 2.根据文件名称,读取路径let path : String? = Bundle.main.path(forResource: &quot;123.plist&quot;, ofType: nil)// 3.根据string,创建URLlet url = URL(string: &quot;http://www.520it.com/小码哥&quot;)// 4.从字典中取内容let dict : [String : Any] = [&quot;name&quot; : &quot;why&quot;, &quot;age&quot; : 18]dict[&quot;name&quot;]dict[&quot;height&quot;]","categories":[{"name":"Swift","slug":"Swift","permalink":"http://ltx.host/categories/Swift/"}],"tags":[{"name":"Swift基础","slug":"Swift基础","permalink":"http://ltx.host/tags/Swift基础/"},{"name":"基本数据类型","slug":"基本数据类型","permalink":"http://ltx.host/tags/基本数据类型/"}]},{"title":"NavigationBar自动隐藏和显示","slug":"NavigationBarHidden","date":"2017-02-13T01:23:30.000Z","updated":"2017-02-13T08:31:48.000Z","comments":true,"path":"20170213/NavigationBarHidden/","link":"","permalink":"http://ltx.host/20170213/NavigationBarHidden/","excerpt":"LTX.Host UIScrollView中可以实现以下方法使得NavigationBar根据手势滑动方向自动隐藏或者显示。","text":"LTX.Host UIScrollView中可以实现以下方法使得NavigationBar根据手势滑动方向自动隐藏或者显示。 123456789101112- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset&#123; if(velocity.y &gt; 0) &#123; //上滑 隐藏 [self.navigationController setNavigationBarHidden:YES animated:YES]; &#125;else &#123; //下滑 显示 [self.navigationController setNavigationBarHidden:NO animated:YES]; &#125; &#125;","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://ltx.host/categories/Objective-C/"}],"tags":[{"name":"UIScrollView","slug":"UIScrollView","permalink":"http://ltx.host/tags/UIScrollView/"},{"name":"UINavigationBar","slug":"UINavigationBar","permalink":"http://ltx.host/tags/UINavigationBar/"}]},{"title":"iOS中float、double类型直接计算导致精度不准确问题","slug":"NSDecimalNumber","date":"2017-02-10T01:50:51.000Z","updated":"2017-02-10T02:26:32.000Z","comments":true,"path":"20170210/NSDecimalNumber/","link":"","permalink":"http://ltx.host/20170210/NSDecimalNumber/","excerpt":"做金融类App开发，经常涉及到Money的计算问题，特别是在算利息这种情况时会遇到除不尽导致小数位数过多的问题。","text":"做金融类App开发，经常涉及到Money的计算问题，特别是在算利息这种情况时会遇到除不尽导致小数位数过多的问题。 问题引出1234567891011121314 //申请提现金额 double balance = [_withDrawView.balanceField.text doubleValue]; //手续费 double brokerage = 1.00; //预计到账金额 (申请提现金额 - 手续费) double finalBalance = balance -brokerage; //提交需要转成NSNumber NSNumber *b = [NSNumber numberWithDouble:balance]; NSNumber *fb = [NSNumber numberWithDouble:finalBalance]; DLog(@&quot;申请金额:%@ 预计到账金额:%@&quot;,b, fb);// 输入金额为10.21后输出结果 申请金额:10.21 预计到账金额:9.210000000000001 可以看到，经过计算的金额转成NSNumber类型后精度不准确，这不是我们想要的结果！ 解决方案1234567891011// //申请提现金额// NSDecimalNumber *balance = [NSDecimalNumber decimalNumberWithString:[NSString stringWithFormat:@&quot;%@&quot;, _withDrawView.balanceField.text]];// //手续费// NSDecimalNumber* brokerage = [NSDecimalNumber decimalNumberWithString:[NSString stringWithFormat:@&quot;%f&quot;,1.00]];// //预计到账金额 (申请提现金额 - 手续费)// NSDecimalNumber* finalBalance = [balance decimalNumberBySubtracting:brokerage];////// DLog(@&quot;申请金额:%@ 预计到账金额:%@&quot;,balance, finalBalance);// 输入金额为10.21后输出结果 申请金额:10.21 预计到账金额:9.21 这就对了，开发中我们可以把float、double转成NSDecimalNumber类型后再进行+、-、* 、/ 的运算。","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://ltx.host/categories/Objective-C/"}],"tags":[{"name":"double计算","slug":"double计算","permalink":"http://ltx.host/tags/double计算/"},{"name":"精度丢失","slug":"精度丢失","permalink":"http://ltx.host/tags/精度丢失/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-02-09T10:39:27.000Z","updated":"2017-02-09T10:39:27.000Z","comments":true,"path":"20170209/hello-world/","link":"","permalink":"http://ltx.host/20170209/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Could not get BatchedBridge","slug":"BatchedBridge","date":"2017-02-08T12:05:41.000Z","updated":"2017-02-09T15:18:11.000Z","comments":true,"path":"20170208/BatchedBridge/","link":"","permalink":"http://ltx.host/20170208/BatchedBridge/","excerpt":"","text":"Could not get BatchedBridge, make sure your bundle is packaged correctly首先在项目的目录android/app/src/main/下面 查看有没有assets文件夹，如果没有手动创建一个。然后打开终端 cd到项目根目录执行下面命令1react-native bundle --platform android --dev false --entry-file index.android.js --bundle-output android/app/src/main/assets/index.android.bundle --assets-dest android/app/src/main/res/","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://ltx.host/categories/React-Native/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"http://ltx.host/tags/React-Native/"},{"name":"移动端","slug":"移动端","permalink":"http://ltx.host/tags/移动端/"}]},{"title":"iOS Runtime 获取成员变量","slug":"RuntimeGet","date":"2017-02-08T12:05:41.000Z","updated":"2017-02-09T15:30:35.000Z","comments":true,"path":"20170208/RuntimeGet/","link":"","permalink":"http://ltx.host/20170208/RuntimeGet/","excerpt":"","text":"首先包含runtime头文件1#import &lt;objc/runtime.h&gt; 以UITextField为例 1.遍历所有成员变量12345678910111213141516171819+ (void)initialize&#123; unsigned int count = 0; // 拷贝出所有的成员变量列表 Ivar *ivars = class_copyIvarList([UITextField class], &amp;count); for (int i = 0; i&lt;count; i++) &#123; // 取出成员变量 // Ivar ivar = *(ivars + i); Ivar ivar = ivars[i]; // 打印成员变量名字 XMGLog(@&quot;%s %s&quot;, ivar_getName(ivar), ivar_getTypeEncoding(ivar)); &#125; // 释放 free(ivars);&#125; 2.遍历所有属性12345678910111213141516+ (void)initialize&#123; unsigned int count = 0; objc_property_t *properties = class_copyPropertyList([UITextField class], &amp;count); for (int i = 0; i&lt;count; i++) &#123; // 取出属性 objc_property_t property = properties[i]; // 打印属性名字 XMGLog(@&quot;%s &lt;----&gt; %s&quot;, property_getName(property), property_getAttributes(property)); &#125; free(properties);&#125;","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://ltx.host/categories/Objective-C/"}],"tags":[{"name":"Runtime","slug":"Runtime","permalink":"http://ltx.host/tags/Runtime/"},{"name":"iOS","slug":"iOS","permalink":"http://ltx.host/tags/iOS/"}]},{"title":"Swift基本语法之闭包","slug":"SwiftClosures","date":"2017-02-08T12:05:41.000Z","updated":"2017-02-09T16:15:58.000Z","comments":true,"path":"20170208/SwiftClosures/","link":"","permalink":"http://ltx.host/20170208/SwiftClosures/","excerpt":"","text":"主要内容闭包的介绍闭包和OC中的block非常相似 OC中的block是匿名的函数Swift中的闭包是一个特殊的函数block和闭包都经常用于回调 注意:闭包和block一样,第一次使用时可能不习惯它的语法,可以先按照使用简单的闭包,随着学习的深入,慢慢掌握其灵活的运用方法. 闭包的使用block的用法回顾定义网络请求的类12345678910111213141516@interface HttpTool : NSObject- (void)loadRequest:(void (^)())callBackBlock;@end@implementation HttpTool- (void)loadRequest:(void (^)())callBackBlock&#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@&quot;加载网络数据:%@&quot;, [NSThread currentThread]); dispatch_async(dispatch_get_main_queue(), ^&#123; callBackBlock(); &#125;); &#125;);&#125;@end 进行网络请求,请求到数据后利用block进行回调123456- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; [self.httpTool loadRequest:^&#123; NSLog(@&quot;主线程中,将数据回调.%@&quot;, [NSThread currentThread]); &#125;];&#125; block写法总结:12345678block的写法: 类型: 返回值(^block的名称)(block的参数) 值: ^(参数列表) &#123; // 执行的代码 &#125;; 使用闭包代替block定义网络请求的类123456789101112class HttpTool: NSObject &#123; func loadRequest(callBack : ()-&gt;())&#123; dispatch_async(dispatch_get_global_queue(0, 0)) &#123; () -&gt; Void in print(&quot;加载数据&quot;, [NSThread.currentThread()]) dispatch_async(dispatch_get_main_queue(), &#123; () -&gt; Void in callBack() &#125;) &#125; &#125;&#125; 进行网络请求,请求到数据后利用闭包进行回调123456override func touchesBegan(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?) &#123; // 网络请求 httpTool.loadRequest (&#123; () -&gt; () in print(&quot;回到主线程&quot;, NSThread.currentThread()); &#125;)&#125; 闭包写法总结:123456789闭包的写法: 类型:(形参列表)-&gt;(返回值) 技巧:初学者定义闭包类型,直接写()-&gt;().再填充参数和返回值 值: &#123; (形参) -&gt; 返回值类型 in // 执行代码 &#125; 闭包的简写如果闭包没有参数,没有返回值.in和in之前的内容可以省略123httpTool.loadRequest(&#123; print(&quot;回到主线程&quot;, NSThread.currentThread()); &#125;) 尾随闭包写法: 如果闭包是函数的最后一个参数,则可以将闭包写在()后面 如果函数只有一个参数,并且这个参数是闭包,那么()可以不写 12345678httpTool.loadRequest() &#123; print(&quot;回到主线程&quot;, NSThread.currentThread());&#125;// 开发中建议该写法httpTool.loadRequest &#123; print(&quot;回到主线程&quot;, NSThread.currentThread());&#125; 闭包的循环引用 •如果在HttpTool中有对闭包进行强引用,则会形成循环引用 •补充:在Swift中检测一个对象是否销毁,可以实现对象的deinit函数 1234// 析构函数(相当于OC中dealloc方法) deinit &#123; print(&quot;ViewController----deinit&quot;) &#125; 循环引用的(实现) 该实现是为了产生循环引用,而产生的循环引用 123456789101112131415class HttpTool: NSObject &#123; // 定义属性,来强引用传入的闭包 var callBack : (()-&gt;())? func loadRequest(callBack : ()-&gt;())&#123; dispatch_async(dispatch_get_global_queue(0, 0)) &#123; () -&gt; Void in print(&quot;加载数据&quot;, [NSThread.currentThread()]) dispatch_async(dispatch_get_main_queue(), &#123; () -&gt; Void in callBack() &#125;) &#125; self.callBack = callBack &#125;&#125; swift中解决循环引用的方式方案一: 使用weak,对当前控制器使用弱引用但是因为self可能有值也可能没有值,因此weakSelf是一个可选类型,在真正使用时可以对其强制解包(该处强制解包没有问题,因为控制器一定存在,否则无法调用所在函数) 123456// 解决方案一: weak var weakSelf = self httpTool.loadData &#123; print(&quot;加载数据完成,更新界面:&quot;, NSThread.currentThread()) weakSelf!.view.backgroundColor = UIColor.redColor() &#125; 方案二: 和方案一类型,只是书写方式更加简单 可以写在闭包中,并且在闭包中用到的self都是弱引用 1234httpTool.loadData &#123;[weak self] () -&gt; () in print(&quot;加载数据完成,更新界面:&quot;, NSThread.currentThread()) self!.view.backgroundColor = UIColor.redColor() &#125; 方案三:(常用) ◦ 使用关键字`unowned` ◦ 从行为上来说 unowned 更像OC中的 unsafe_unretained ◦ unowned 表示:即使它原来引用的对象被释放了，仍然会保持对被已经释放了的对象的一个 &quot;无效的&quot; 引用，它不能是 Optional 值，也不会被指向 nil 1234httpTool.loadData &#123;[unowned self] () -&gt; () in print(&quot;加载数据完成,更新界面:&quot;, NSThread.currentThread()) self.view.backgroundColor = UIColor.redColor() &#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"http://ltx.host/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://ltx.host/tags/Swift/"},{"name":"闭包","slug":"闭包","permalink":"http://ltx.host/tags/闭包/"}]}]}