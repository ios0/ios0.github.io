{"meta":{"title":"Mr.Liu","subtitle":"Write the Code. Change the world.","description":"Write the Code. Change the world.","author":"Mr.Liu","url":"http://swift.fit"},"pages":[{"title":"categories","date":"2017-02-09T10:56:25.000Z","updated":"2017-02-10T06:08:39.000Z","comments":false,"path":"categories/index.html","permalink":"http://swift.fit/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-02-09T10:56:16.000Z","updated":"2017-02-10T06:08:36.000Z","comments":false,"path":"tags/index.html","permalink":"http://swift.fit/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"iOS中float、double类型直接计算导致精度不准确问题","slug":"NSDecimalNumber","date":"2017-02-10T01:50:51.000Z","updated":"2017-02-10T02:26:32.000Z","comments":true,"path":"20170210/NSDecimalNumber/","link":"","permalink":"http://swift.fit/20170210/NSDecimalNumber/","excerpt":"做金融类App开发，经常涉及到Money的计算问题，特别是在算利息这种情况时会遇到除不尽导致小数位数过多的问题。","text":"做金融类App开发，经常涉及到Money的计算问题，特别是在算利息这种情况时会遇到除不尽导致小数位数过多的问题。 问题引出1234567891011121314 //申请提现金额 double balance = [_withDrawView.balanceField.text doubleValue]; //手续费 double brokerage = 1.00; //预计到账金额 (申请提现金额 - 手续费) double finalBalance = balance -brokerage; //提交需要转成NSNumber NSNumber *b = [NSNumber numberWithDouble:balance]; NSNumber *fb = [NSNumber numberWithDouble:finalBalance]; DLog(@&quot;申请金额:%@ 预计到账金额:%@&quot;,b, fb);// 输入金额为10.21后输出结果 申请金额:10.21 预计到账金额:9.210000000000001 可以看到，经过计算的金额转成NSNumber类型后精度不准确，这不是我们想要的结果！ 解决方案1234567891011// //申请提现金额// NSDecimalNumber *balance = [NSDecimalNumber decimalNumberWithString:[NSString stringWithFormat:@&quot;%@&quot;, _withDrawView.balanceField.text]];// //手续费// NSDecimalNumber* brokerage = [NSDecimalNumber decimalNumberWithString:[NSString stringWithFormat:@&quot;%f&quot;,1.00]];// //预计到账金额 (申请提现金额 - 手续费)// NSDecimalNumber* finalBalance = [balance decimalNumberBySubtracting:brokerage];////// DLog(@&quot;申请金额:%@ 预计到账金额:%@&quot;,balance, finalBalance);// 输入金额为10.21后输出结果 申请金额:10.21 预计到账金额:9.21 这就对了，开发中我们可以把float、double转成NSDecimalNumber类型后再进行+、-、* 、/ 的运算。","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://swift.fit/categories/Objective-C/"}],"tags":[{"name":"double计算","slug":"double计算","permalink":"http://swift.fit/tags/double计算/"},{"name":"精度丢失","slug":"精度丢失","permalink":"http://swift.fit/tags/精度丢失/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-02-09T10:39:27.000Z","updated":"2017-02-09T10:39:27.000Z","comments":true,"path":"20170209/hello-world/","link":"","permalink":"http://swift.fit/20170209/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Could not get BatchedBridge","slug":"BatchedBridge","date":"2017-02-08T12:05:41.000Z","updated":"2017-02-09T15:18:11.000Z","comments":true,"path":"20170208/BatchedBridge/","link":"","permalink":"http://swift.fit/20170208/BatchedBridge/","excerpt":"","text":"Could not get BatchedBridge, make sure your bundle is packaged correctly首先在项目的目录android/app/src/main/下面 查看有没有assets文件夹，如果没有手动创建一个。然后打开终端 cd到项目根目录执行下面命令1react-native bundle --platform android --dev false --entry-file index.android.js --bundle-output android/app/src/main/assets/index.android.bundle --assets-dest android/app/src/main/res/","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://swift.fit/categories/React-Native/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"http://swift.fit/tags/React-Native/"},{"name":"移动端","slug":"移动端","permalink":"http://swift.fit/tags/移动端/"}]},{"title":"iOS Runtime 获取成员变量","slug":"RuntimeGet","date":"2017-02-08T12:05:41.000Z","updated":"2017-02-09T15:30:35.000Z","comments":true,"path":"20170208/RuntimeGet/","link":"","permalink":"http://swift.fit/20170208/RuntimeGet/","excerpt":"","text":"首先包含runtime头文件1#import &lt;objc/runtime.h&gt; 以UITextField为例 1.遍历所有成员变量12345678910111213141516171819+ (void)initialize&#123; unsigned int count = 0; // 拷贝出所有的成员变量列表 Ivar *ivars = class_copyIvarList([UITextField class], &amp;count); for (int i = 0; i&lt;count; i++) &#123; // 取出成员变量 // Ivar ivar = *(ivars + i); Ivar ivar = ivars[i]; // 打印成员变量名字 XMGLog(@&quot;%s %s&quot;, ivar_getName(ivar), ivar_getTypeEncoding(ivar)); &#125; // 释放 free(ivars);&#125; 2.遍历所有属性12345678910111213141516+ (void)initialize&#123; unsigned int count = 0; objc_property_t *properties = class_copyPropertyList([UITextField class], &amp;count); for (int i = 0; i&lt;count; i++) &#123; // 取出属性 objc_property_t property = properties[i]; // 打印属性名字 XMGLog(@&quot;%s &lt;----&gt; %s&quot;, property_getName(property), property_getAttributes(property)); &#125; free(properties);&#125;","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://swift.fit/categories/Objective-C/"}],"tags":[{"name":"Runtime","slug":"Runtime","permalink":"http://swift.fit/tags/Runtime/"},{"name":"iOS","slug":"iOS","permalink":"http://swift.fit/tags/iOS/"}]},{"title":"Swift基本语法之闭包","slug":"SwiftClosures","date":"2017-02-08T12:05:41.000Z","updated":"2017-02-09T16:15:58.000Z","comments":true,"path":"20170208/SwiftClosures/","link":"","permalink":"http://swift.fit/20170208/SwiftClosures/","excerpt":"","text":"主要内容闭包的介绍闭包和OC中的block非常相似 OC中的block是匿名的函数Swift中的闭包是一个特殊的函数block和闭包都经常用于回调 注意:闭包和block一样,第一次使用时可能不习惯它的语法,可以先按照使用简单的闭包,随着学习的深入,慢慢掌握其灵活的运用方法. 闭包的使用block的用法回顾定义网络请求的类12345678910111213141516@interface HttpTool : NSObject- (void)loadRequest:(void (^)())callBackBlock;@end@implementation HttpTool- (void)loadRequest:(void (^)())callBackBlock&#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@&quot;加载网络数据:%@&quot;, [NSThread currentThread]); dispatch_async(dispatch_get_main_queue(), ^&#123; callBackBlock(); &#125;); &#125;);&#125;@end 进行网络请求,请求到数据后利用block进行回调123456- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; [self.httpTool loadRequest:^&#123; NSLog(@&quot;主线程中,将数据回调.%@&quot;, [NSThread currentThread]); &#125;];&#125; block写法总结:12345678block的写法: 类型: 返回值(^block的名称)(block的参数) 值: ^(参数列表) &#123; // 执行的代码 &#125;; 使用闭包代替block定义网络请求的类123456789101112class HttpTool: NSObject &#123; func loadRequest(callBack : ()-&gt;())&#123; dispatch_async(dispatch_get_global_queue(0, 0)) &#123; () -&gt; Void in print(&quot;加载数据&quot;, [NSThread.currentThread()]) dispatch_async(dispatch_get_main_queue(), &#123; () -&gt; Void in callBack() &#125;) &#125; &#125;&#125; 进行网络请求,请求到数据后利用闭包进行回调123456override func touchesBegan(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?) &#123; // 网络请求 httpTool.loadRequest (&#123; () -&gt; () in print(&quot;回到主线程&quot;, NSThread.currentThread()); &#125;)&#125; 闭包写法总结:123456789闭包的写法: 类型:(形参列表)-&gt;(返回值) 技巧:初学者定义闭包类型,直接写()-&gt;().再填充参数和返回值 值: &#123; (形参) -&gt; 返回值类型 in // 执行代码 &#125; 闭包的简写如果闭包没有参数,没有返回值.in和in之前的内容可以省略123httpTool.loadRequest(&#123; print(&quot;回到主线程&quot;, NSThread.currentThread()); &#125;) 尾随闭包写法: 如果闭包是函数的最后一个参数,则可以将闭包写在()后面 如果函数只有一个参数,并且这个参数是闭包,那么()可以不写 12345678httpTool.loadRequest() &#123; print(&quot;回到主线程&quot;, NSThread.currentThread());&#125;// 开发中建议该写法httpTool.loadRequest &#123; print(&quot;回到主线程&quot;, NSThread.currentThread());&#125; 闭包的循环引用 •如果在HttpTool中有对闭包进行强引用,则会形成循环引用 •补充:在Swift中检测一个对象是否销毁,可以实现对象的deinit函数 1234// 析构函数(相当于OC中dealloc方法) deinit &#123; print(&quot;ViewController----deinit&quot;) &#125; 循环引用的(实现) 该实现是为了产生循环引用,而产生的循环引用 123456789101112131415class HttpTool: NSObject &#123; // 定义属性,来强引用传入的闭包 var callBack : (()-&gt;())? func loadRequest(callBack : ()-&gt;())&#123; dispatch_async(dispatch_get_global_queue(0, 0)) &#123; () -&gt; Void in print(&quot;加载数据&quot;, [NSThread.currentThread()]) dispatch_async(dispatch_get_main_queue(), &#123; () -&gt; Void in callBack() &#125;) &#125; self.callBack = callBack &#125;&#125; swift中解决循环引用的方式方案一: 使用weak,对当前控制器使用弱引用但是因为self可能有值也可能没有值,因此weakSelf是一个可选类型,在真正使用时可以对其强制解包(该处强制解包没有问题,因为控制器一定存在,否则无法调用所在函数) 123456// 解决方案一: weak var weakSelf = self httpTool.loadData &#123; print(&quot;加载数据完成,更新界面:&quot;, NSThread.currentThread()) weakSelf!.view.backgroundColor = UIColor.redColor() &#125; 方案二: 和方案一类型,只是书写方式更加简单 可以写在闭包中,并且在闭包中用到的self都是弱引用 1234httpTool.loadData &#123;[weak self] () -&gt; () in print(&quot;加载数据完成,更新界面:&quot;, NSThread.currentThread()) self!.view.backgroundColor = UIColor.redColor() &#125; 方案三:(常用) ◦ 使用关键字`unowned` ◦ 从行为上来说 unowned 更像OC中的 unsafe_unretained ◦ unowned 表示:即使它原来引用的对象被释放了，仍然会保持对被已经释放了的对象的一个 &quot;无效的&quot; 引用，它不能是 Optional 值，也不会被指向 nil 1234httpTool.loadData &#123;[unowned self] () -&gt; () in print(&quot;加载数据完成,更新界面:&quot;, NSThread.currentThread()) self.view.backgroundColor = UIColor.redColor() &#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"http://swift.fit/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://swift.fit/tags/Swift/"},{"name":"闭包","slug":"闭包","permalink":"http://swift.fit/tags/闭包/"}]}]}